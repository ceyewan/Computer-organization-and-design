## 指令：计算机语言

### 引言

计算机语言中的基本单词称为指令，一台计算机的全部指令称计算机的指令集。指令集具有两种形式：

- 人们编程书写的形式
- 计算机能够识别的形式

存储程序概念：多种类型的指令和数据均以数字形式存储于存储器的概念。

MIPS操作数

| 名字         | 示例                              | 注释                                                         |
| ------------ | --------------------------------- | ------------------------------------------------------------ |
| 32个寄存器   | $s0 - $s7, $t0 - $t9, $zero , $at | 寄存器用于数据的快速存取。MIPS只能对存放在寄存器中的数据执行算术操作，$zero的值恒为0，$at被汇编器保留用来处理大的常数 |
| 2^30个存储字 | Memory[0]  Memory[4]  Memory[404] | 存储器只能通过数据传输指令访问，MIPS使用字节编址，所以连续的字地址相差4。存储器用于保存数据结构、数组、和溢出的寄存器 |

MIPS汇编语言

![image-20211117142836173](https://gitee.com/ceyewan/pic/raw/master/images/image-20211117142836173.png)
![image-20211117142928938](https://gitee.com/ceyewan/pic/raw/master/images/image-20211117142928938.png)

------

### 计算机硬件的操作

- 硬件设计的三条基本原则之一：简单源于规整。

加法指令：

```
add a, b, c
```

表示两个变量 b 和 c 相加，存放到 a 中。这种记法是固定的，每条MIPS指令只执行一个操作，并且有且仅有3个变量。如：

```assembly
C代码： a = b + c + d + e

MIPS指令：
add a, b, c
add a, a, d
add a, a, e
```

又如：

```assembly
a = b + c
d = a - e

add a, b, c
sub d, a, e
```

### 计算机硬件的操作数

MIPS体系结构中寄存器的大小为32，将其称为字。

字：

​	计算机中的基本访问单元，通常是32位为一组，在MIPS体系结构中与寄存器大小相同。

MIPS一类的现代计算机中有32个寄存器。

- 硬件设计三条基本原则之二：越小越快

MIPS约定书写指令时用一个 $ 后面跟两个字符来代表一个寄存器。我们使用$s0、$s1……表示与C和Java程序中的变量对应的寄存器；用$t0、$t1……来表示程序编译为MIPS指令时所需要的临时寄存器。

```assembly
f = (g + h) - (i + j);
变量f、g、h、i、j依次分配给寄存器$s0、$s1、$s2、$s3、$s4

add $t0, $s1, $s2
add $t1, $s3, $s4
sub $s0, $t0, $t1
```

#### 存储器操作数

MIPS的算术运算指令只对寄存器进行操作，因此，必然有包含在存储器和寄存器之间传输数据的指令，叫做数据传输指令。为了访问存储器中的一个字，指令必须给出存储器地址。

- **取数指令（load）**

  将数据从存储器复制到寄存器的数据传送指令。格式是操作码后接着目标寄存器，再后来是用来访问存储器的常数和寄存器。助记符：**lw**（load word）

  - 偏移量：数据传送指令中的常量
  - 基址寄存器：存放基址的寄存器
  - 对齐限制：MIPS是按照字节编址的，所以字的起始地址必须是4的倍数（大端序或小端序）

```assembly
g = h + A[8];

lw $t0, 8($s3) # 实际上应该是32
add $s1, $s2, $t0
```

- **存数指令（store）**

  将数据从寄存器复制到存储器，助记符：**sw**

  - 将不常使用的变量存回存储器的过程叫寄存器溢出

```assembly
A[12] = h + A[8];

lw $t0, 32($s3)
add $t0, $t0, $s1
sw $t0, 48($s3)
```

#### 常数或立即数操作数

```
addi $s3, $s3, 4
```

常数0还有另外的作用，有效的使用可以简化指令集。数据传送指令正好可以被视作一个操作数为0的加法。因此，MIPS将寄存器$zero恒置为0。根据使用频率来确定要定义的常数是**加速大概率事件**的好办法。

--------

### 有符号数和无符号数

二进制数位（位）：信息的基本组成单位，即0或者1

- 最高有效位：MIPS字中最左边的一位（第31位）
- 最低有效位：MIPS字中最右边的一位（第0位）
- 如果操作结果不能被最右端的硬件位所表示，就会发生溢出（没懂）
- 补码：取反加一
- 对取数指令来说：取回有符号数后需要使用符号位填充寄存器的所有剩余位，称为**符号拓展**。取回无符号数只是简单的用0来填充左侧的剩余位。

MIPS提供两种字节加载的方法：

- 用于字节加载的lb，将字节看作有符号数，使用符号拓展来填充寄存器左侧的24位
- 用于无符号整数加载的lbu，实际上C语言几乎所有的字节加载都使用lbu

处理二进制补码数的简单方法：

- 对二进制补码数取反的快速方法，取反加一

-------

### 计算机中指令的表示

$t0 - $t7映射到寄存器8 ~15

$s0 - $s7映射到寄存器16~23

| 表示方法   | 形式                                  |
| ---------- | ------------------------------------- |
| MIPS指令   | add $t0, $s1, $s2                     |
| 十进制表示 | 0 17 18 8 0 32                        |
| 二进制表示 | 000000 10001 10010 01000 00000 100000 |
| 位数       | 6 5 5 5 5 6                           |

机器指令分为若干**字段（field）**

- 本例中第一个字段和最后一个字段组合起来告诉MIPS计算机该指令要完成加法运算；
- 第二和第三个操作数表示加法的第一第二个源操作数寄存器号；
- 第四个字段表示存放运算结果的目的寄存器号；
- 第五个字段没有用到，置为0。

指令的布局形式叫做指令格式，为了将它和汇编语言区分开，把指令的数字形式称为机器语言，这样的指令序列叫做机器码。

C和Java中用符号0xnnnn来表示十六进制

MIPS字段：

- R型（用于寄存器）

| op                           | rs                   | rt                   | rd                       | shamt  | funct                        |
| :--------------------------- | -------------------- | -------------------- | ------------------------ | ------ | ---------------------------- |
| 6位                          | 5位                  | 5位                  | 5位                      | 5位    | 6位                          |
| 操作码：表示操作和格式的字段 | 第一个源操作数寄存器 | 第二个源操作数寄存器 | 存放操作结果的目的寄存器 | 位移量 | 功能码：指明op字段的特定变式 |

最后一条硬件设计原则：优秀的设计需要适宜的折中方案

- I型（用于立即数）

| op     | rs         | rt             | constant address  |
| ------ | ---------- | -------------- | ----------------- |
| 6位    | 5位        | 5位            | 16位              |
| 操作码 | 基址寄存器 | **目标寄存器** | 偏移量（address） |

**由第一个字段来区分这两种指令**

![image-20211117182455231](https://gitee.com/ceyewan/pic/raw/master/images/image-20211117182455231.png)

```assembly
A[300] = h + A[300]

lw $t0, 1200($t1)	# reg $t0 gets A[300]
add $t0, $s2, $t0	# reg $t0 gets h + A[300]
sw $t0, 1200($t1)	# stores h + A[300] back into A[300]
```

对应的机器指令：

| op   | rs   | rt   | rd   | address/shamt    | funct |
| ---- | ---- | ---- | ---- | ---------------- | ----- |
| 35   | 9    | 8    |      | 1200（占据三格） |       |
| 0    | 18   | 8    | 8    | 0                | 32    |
| 43   | 9    | 8    |      | 1200（占据三格） |       |

![image-20211117185255384](https://gitee.com/ceyewan/pic/raw/master/images/image-20211117185255384.png)

当今计算机基于一下两个重要准则构建：

- 指令用数的形式表示（二进制兼容）
- 和数据一样，程序存储在存储器中，并且可以读写

存储程序：

存储器可以存放编辑器程序的源代码、与之对应的编译后的机器码、编译后的程序需要使用的文本、用于生成机器码的编译器。

--------

### 逻辑操作

| 逻辑操作 | C操作符 | MIPS指令  |
| :------: | ------- | --------- |
|   左移   | <<      | sll       |
|   右移   | >>      | srl       |
|  按位与  | &       | and，andi |
|  按位或  | \|      | or，ori   |
| 按位取反 | ~       | not       |

```assembly
sll $t2, $s0, 4	# reg $t2 = reg $s0 << 4 bits
```

shamt字段：在位移指令中用于表示位移量

| op   | rs   | rt   | rd   | shamt | funct |
| ---- | ---- | ---- | ---- | ----- | ----- |
| 0    | 0    | 16   | 10   | 4     | 0     |

rs字段没有使用，被置为0

第二类逻辑运算：

```assembly
and $t0, $t1, $t2	# reg $t0 = reg $t1 & reg $t2
or $t0, $t1, $t2	# reg $t0 = reg $t1 | reg $t2
nor $t0, $t1, $t2	# reg $t0 = ~(reg $t1 | reg $t2)($t2默认为0)
```

nor = not or(或非) 如果一个操作数是0，那么就等价于 not 操作。还有异或操作（xor）

--------

### 决策指令

条件分支指令：

- **beq（如果相等则分支）（branch if equal）**：beq register1, register2, L1

  如果register1和register2中的数值相等，则转到标签为L1的语句执行。

- **bne（如果不相等则分支）：bne register1, register2**, L1

  如果register1和register2中的数值不相等，则转到标签为L1的语句执行。

```assembly
if (i == j)
	f = g + h;
else 
	f = g - h;
	
bne $s3, $s4, Else	# 如果不等，跳转到Else
add $s0, $s1, $s2
j Exit	# MIPS将无条件分支指令命名为jump，简写为j
Else:sub $s0, $s1, $s2
Exit:
```

#### 循环

```assembly
while (save[i] == k)
	i += 1;
	
Loop:sll $t1, $s3, 2	#将i乘以4（左移两位）（按照字节寻址）
add $t1, $t1, $s6	# 将i和save的地址加起来获得最终地址
lw $t0, 0($t1)	# 从地址取数到t0
bne $t0, $s5, Exit	# 如果不等，则退出
addi $s3, $s3, 1	# 自加
j Loop	# 跳转回去
Exit:
```

小于则置位：slt、sltu

```assembly
slt $t0, $s3, $s4 	# $t0 = 1 if $s3 < $s4
slti $t0, $s3, 10 	# $t0 = 1 if $s3 < 10
```

- sltu和sltiu用于处理无符号数

将有符号数作为无符号数来处理，是一种检验0<=x<y的低开销方法，常用来检查数组是否越界。（因为负数首位为 1 ，可以看作很大的数，因此只要判断 x < y 即可。

```assembly
sltu $t0, $s1, $s2	# t0 = 0 if s1 >= s2 or s1 < 0
beq $t0, $zero, IndexOutOfBounds # if t0 = 0, goto IndexOutOfBounds
```

#### case/switch语句

将多个指令序列分支的地址编码成一张表，即转移地址表或转移表

- **寄存器跳转指令jr（jump register）**

------------------------------------

### 计算机硬件对过程的支持

**过程**或函数是程序员进行结构化编程的工具，有助于提高程序的可理解性和代码的可重用性。过程是软件中实现抽象的一种方法。

***过程***：根据提供的参数执行一定任务的存储的子程序

在过程运行中，程序必须遵循以下6个步骤：

- 将参数放在过程可以访问的位置
- 将控制交给过程
- 获得过程所需的存储资源
- 执行需要的任务
- 将结果的值放在调用程序可以访问的位置
- 将控制返回初始点，因为一个过程可能由一个程序的多个点调用

计算机中保存数据最快的位置是寄存器，所以我们希望尽可能多的使用寄存器。MIPS软件在为过程调用分配32个寄存器时遵循以下约定：

- $a0 - $a3：用于传递参数的4个参数寄存器
- $v0 - $v1：用于返回值的两个值寄存器
- ra：用于返回起始点的返回地址寄存器

MIPS汇编语言还包括一条过程调用指令：跳转到某个地址的同时将下一条指令的地址保存到寄存器$ra中，叫做**跳转和链接指令**。

- 格式：`jal ProcedureAddress`

指令中的链接部分表示指向调用点的地址或链接，以允许过程返回到合适的地址。存储在寄存器$ra中的链接部分称为**返回地址**。返回地址是必须的，因为同一过程可能在程序的不同部分调用。

- 跳转和链接指令：调准啊到某个地址的同时将下一条指令的地址保存到寄存器$ra中的指令
- 返回地址：指向调用点的链接，是过程可以返回到合适的地址，在MIPS中它存储在寄存器$ra中

类似MIPS的计算机使用寄存器跳转（jump register）指令jr，用于case语句，表示无条件跳转到寄存器所指定的地址：

jr $ra

调用程序或称为**调用者**，将参数放在$a0 - $a3，然后使用jal X跳转到过程X（有时被称为**被调用者**）。被调用者执行运算，将结果放在$v0 - $v1，然后使用jr $ra指令将控制返回个调用者。

**程序计时器**：在MIPS指令中缩写为PC，保存当前运行的指令地址。jal指令实际上将PC + 4保存在寄存器$ra中，从而将链接指向下一条指令，为过程返回做好准备。

- 调用者：调用一个过程并为过程提供必要参数值的程序
- 被调用者：根据调用者提供的参数执行一系列存储的指令，然后将控制权返回调用者的过程
- 程序计时器（PC）：包含在程序中正在被执行指令地址的寄存器。

#### 使用更多的寄存器

假设对于一个过程，编译器需要使用多于4个参数寄存器和两个返回值寄存器，由于在文物完成后必须消除痕迹，因此调用者使用的任何寄存器都必须恢复到过程调用之前所存储的值。那么我们就可以先存进存储器，调用过程结束后再取出。换出寄存器最理想的数据结构是**栈**。

栈需要一个指针指向栈中最新分配的地址，以指示下一个过程放置换出寄存器的位置，或是寄存器旧值的存放位置。每次寄存器进行保存或者恢复时，栈指针以字为单位进行调整。MIPS为栈指针准备了第29号寄存器，并将其命名为$sp。将数据放入栈中称为压栈（push），从栈中移除数据称为出栈（pop）。

- 栈：被组织成后进先出队列形式并用于寄存器换出的数据结构
- 栈指针：指示栈中最近分配的地址的值，指示寄存器被换出的位置，或寄存器旧值的存放位置。在MIPS中，栈指针的寄存器时$sp
- 压栈：向栈中增加元素
- 出栈：从栈中移除元素

按照历史惯例，栈“增长”是按照地址从高到低的顺序进行的。这意味着将数据压栈时，栈指针值减少；而数据出栈时，栈指针增大。

```c
int leaf_example(int g, int h, int i, int j)
{
	int f;
	f = (g + h) - (i + j);
	return f;
}
```

参数变量g、h、i、j对应参数寄存器$a0, $a1, $a2, $a3， f 对应 $s0

```assembly
leaf_example:	# 编译后的程序时以如下标号开始的过程
# 将要用到的一些寄存器里面的旧值压栈
addi $sp, $sp, -12 # 三个空间
sw $t1, 8($sp)	
sw $t0, 4($sp)
sw $s0, 0($sp)
# 计算
add $t0, $a0, $a1
add $t1, $a2, $a3
sub $s0, $t0, $t1
# 将$s0复制到一个返回值寄存器中
add $v0, $s0, $zero
# 恢复寄存器中的三个旧值
lw $s0, 0($sp)
lw $t0, 4($sp)
lw $t1, 8($sp)
addi $sp, $sp, 12
# 根据跳转寄存器中的返回地址跳转
jr $ra
```

为了避免保存和恢复一个其值未被使用过的寄存器，MIPS软件将18个寄存器分为两组：

- $t0 - $t9：10个临时寄存器，在过程调用中不必被调用者保存，
- $s0 - $s7：8个保留寄存器，在过程调用中必须被保存

#### 嵌套过程

不调用其他过程的过程叫做*叶过程*

```c
int fact(int n)
{
	if (n < 1)	return 1;
	else	return n * fact(n - 1);
}
```

MIPS汇编代码：

```assembly
# 参变量n对应参数寄存器$a0
fact:	# 调用fact
	addi $sp, $sp, -8	#栈
	sw $ra 4($sp)	# 将该过程的返回地址压栈
	sw $a0, 0($sp)	# 将n压栈
	
	slti $t0, $a0, 1	# test for n < 1，保存于$t0
	beq $t0, $zero, L1	# if $t0 = 0,go to L1
	
	# n == 1的情况，倒也不必像下面一样复杂
	addi $v0, $zero, 1	# $v0 = 1
	addi $sp, $sp, 8	# 出栈
	jr $ra	返回调用者
	
L1:addi $a0, $a0, -1	# n--
	jal fact	# 调用过程
	
    lw $a0, 0($sp)	# 出栈
    lw $ra, 4($sp)
    addi $sp, $sp, 8

    mul $v0, $a0, $v0 # 得到结果

    jr $ra	# 返回调用者
```

全局指针：指向静态数据区的保留寄存器

MIPS软件保留了另一个寄存器，称为全局指针，即$gp，用于简化静态数据的访问。

![image-20211118000455083](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118000455083.png)

#### 在栈中为新数据分配空间

栈的最后一点复杂性是栈还需要存储过程的局部变量，这些变量不适于寄存器，例如局部的数组或结构体。

栈中包含的寄存器和局部变量的片段称为**过程帧**或**活动记录**

过程调用之前、之中、之后栈的状态：

![image-20211118101111416](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118101111416.png)

某些MIPS软件使用**帧指针**指向过程帧的第一个字。

- 过程帧：也称作活动记录，栈中包含过程所保存的寄存器以及局部变量的片段。
- 帧指针：指向给定过程中保存的寄存器和局部变量的值

#### 在堆中为新数据分配空间

除了动态变量对过程是局部的有效的之外，C程序员还需要在内存中为静态变量和动态数据结构提供空间。

MIPS分配内存的约定：

栈由内存高端开始并向下增长，内存低端的第一部分是保留的，之后是MIPS机器代码的第一部分，通常称为**代码段**。代码段之上的代码称为**静态数据段**，是存储常量的其他静态变量的空间。链表这种在生命周期内能狗增长或缩短的动态数据结构对应的段习惯上称为**堆**，一般存放在静态数据段之后。这种分配允许栈和堆相互增长，从而在两个段此消彼长的过程中达到内存的高效利用。

![image-20211118103312245](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118103312245.png)

MIPS汇编语言的寄存器约定：

![image-20211118103535610](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118103535610.png)

这种约定是**加速大概率事件**的另一个例子。

如果参数多于4个怎么办？MIPS约定将额外的参数放在栈中帧指针的上方。这样，过程从寄存器$a0 - $a3中获得前四个参数，通过帧指针在内存中寻址获得其余参数。

![image-20211118104227890](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118104227890.png)

```assembly
sum:slti $t0, $a0, 1	# test if n <= 0
	bne $t0, $zero, sum_exit	# 不等则跳转
    
	add $a1, $a1, $a0	# 把n加到答案里
	addi $a0, $a0, -1	# n--
	j sum	# 跳转到sum
	
sum_exit:
	add $v0, $a1, $zero	#v0 = a1
	jr $ra	#返回调用者
```

编译器自动优化为迭代，类似于while循环。

------------------------------------

### 人机交互

ASCII码表：小写字母97，大写字母65，相差32

字节读取lb（load byte）指令从内存中读取一个字节，并将其放在一个寄存器最右边的8位。

字节存储sb（store byte）指令把寄存器最右边的8位取出来然后写到内存中。

```c
void strcpy(char x[], char y[])
{
	int i;
    i = 0;
    while ((x[i] = y[i]) != '\0')
        i += 1;
}
```

MIPS汇编指令：

假定数组 x 和 y 的基地址在 $a0 ,  $a1 中，而 i 在 $s0 中，要把 i 保存到 $s0 中，就要先把 $s0 中的数据压栈存起来。

```assembly
# 调整栈指针然后将保存的寄存器 $s0 保存在栈中
strcpy:
	addi $sp, $sp, -4
	sw $s0, 0($sp)

	add $s0, $zero, $zero 	# i= 0 + 0
	
L1:	add $t1, $s0, $a1		# t1 = y[i]的地址
	lbu $t2, 0($t1)			# t2 = y[i]
	
	add $t3, $s0, $a0		# t3 = x[i]的地址
	sb $t2, 0($t3)			# x[i] = y[i]
	
	beq $t2, $zero, L2		# 如果t2 = 0,退出循环
	
	addi $s0, $t0, 1		# i++
	j L1					# 循环
	
L2:	lw $s0, 0($sp)			# 恢复s0和sp
	addi $sp, $sp, 4
	jr $ra					# 返回调用者
```

#### Java中的字符和字符串

Unicode编码

- lh ：读半字的指令
- sh ：存半字的指令
- shu 和 lhu

-----------------------------

### MIPS中32位立即数和寻址

#### 32位立即数

MIPS指令集中的读取立即数高位指令 lui 专门用于设置寄存器中常数的高16位，允许后续指令设置常数的低16位。

```
lui $t0, 255	# $t0 is register 8
```

对应的机器语言：

| op     | rs    | rt    | constant address  |
| ------ | ----- | ----- | ----------------- |
| 001111 | 00000 | 01000 | 00000000 11111111 |

执行后，寄存器$t0的值：

```
00000000 11111111 00000000 00000000
```

- lui指令：将16位的立即数常量存放到寄存器的高16位， 低16位用0填充

将32位常量加载到寄存器$s0的MIPS指令：

```assembly
0000 0000 0011 1101 0000 1001 0000 0000

lui $s0, 61
ori $s0, $s0, 2304	# 或运算
```

上面的 ori 用 addi 可以吗？书上说，指令 addi 将指令最左边的16位立即数字段复制到一个字的高16位中。ori 把0 读到高16位中，所以可以被汇编程序用于和 lui 一起创建32位常数。

我只能说不知所云，应该是翻译的锅。我们知道， addi是有符号加法，如果16位立即数是 1000000000000001，那么符号拓展后是 11111111111111111 1000000000000001，再相加就出错了。而 ori 高 16位永远是 0，所以没问题。（addiu应该没问题吧）

编译器或汇编器必须将大的常数分解为若干小的常数，然后再合并到一个寄存器中。因此汇编程序必须有一个可用的临时寄存器来创建长整数值，这是给汇编程序保留 $at 寄存器的一个原因。

#### 分支和跳转中的寻址

- **J型跳转指令**

（下面这个指令是： j 10000

| op     | address                    |
| ------ | -------------------------- |
| 000010 | 00000000000000000000010000 |
| 6位    | 26位地址字段               |

（实际上要更加复杂一些）

- 条件分支指令

```assembly
bne $s0, $s1, Exit	# go to Exit if $s0 != $s1
```

| op   | rs   | rt   | address |
| ---- | ---- | ---- | ------- |
| 2    | 16   | 17   | Exit    |
| 6位  | 5位  | 5位  | 16位    |

跳转指令比条件分支指令的地址范围更大。

另一个办法：

​	指定一个总是加到分支地址上的寄存器，这样分支指令的地址可按如下方式计算：

- 程序计时器（PC，下一条执行的指令） = 寄存器 + 分支地址

我们可以使用PC来作为增加地址的寄存器。这种分支寻址的方式称为 **PC相对寻址** 。

MIPS寻址实际上是相对于下一条指令的地址（PC + 4），而不是相对于当前指令的地址（PC）。

寻址附近的指令是**加速大概率事件**的另一个例子。

- PC相对寻址：一种寻址方式，它将PC和指令中的常数相加作为寻址结果

MIPS对所有条件分支使用PC相对寻址，因为这些指令的跳转目标一般都比较接近其分支地址。另一方面。跳转链接指令并非总是靠近调用者的过程，所以它们通常使用其他寻址方式。

MIPS体系结构通过使用跳转和跳转链接指令的J型格式来为过程调用提供长地址。

```assembly
while (save[i] == k)
	i += 1;
	
Loop：sll $t1, $s3, 2	# $t1 = 4 * i
	add $t1, $t1, $s6	# $t1 = save[i]的地址
	lw $t0, 0($t1)		# $t0 = save[i]
	bne $t0, $s5,  Exit	# save[i] == k
	addi $s3, $s3, 1	# i++
	j Loop	
Exit:
```

![image-20211118133759775](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118133759775.png)

组合型：

L1超过了 16 位可以表示的怎么办？换成 J 型，26位的

```assembly
beq $s0, $s1, L1 # s0 == s1,跳转到 L1

    bne $s0, $s1, L2 # s0 ！= s1 跳转到L2，继续向后执行
    j	L1 # s0 == s1 跳转到L1，26位
L2:
```

#### MIPS寻址模式总结

![image-20211118140709786](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118140709786.png)

一种操作可能使用多种寻址模式，例如加法可以使用寄存器寻址（add）和立即数寻址（addi）.

寻址模式：根据对操作数和/或地址的使用不同加以区分的多种寻址方式中的一种。

- 立即数寻址：操作数是位于指令自身中的常数（addi）
- 寄存器寻址：操作数是寄存器（add $s0, $s1,8($s2))
- 基址寻址或偏移寻址：操作数在内存中，其地址是指令中基址寄存器和常数的和。(beq, bne)
- PC相对寻址：地址是PC和指令中常数的和（jal jr）
- 伪直接寻址：跳转指令由指令中的26位字段和PC高位相连而成

#### 机器语言解码

解码。先看左边6位（31 - 26）操作数，查表。

![image-20211118142112524](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118142112524.png)

### 并行与指令：同步

某些任务写的结果是其他任务需要读取的值，这时执行读任务的一方要知道写任务什么时候完成了写操作，才能安全的读回数据。就是说，任务之间需要同步，否则就有发生数据竞争的危险。

- 数据竞争：来自不同线程的两个访存请求访问同一个地址，它们连续出现，并且至少其中一个是写操作，那么这两个储存访问形成数据竞争。

加锁和解锁同步操作的实现。采用加锁和解锁可以直接创立一个仅允许单个处理器操作的区域，叫做互斥区。

在多处理器中实现同步需要一组硬件原语，提供对存储单元进行原子读和原子写的能力，是的在进行存储器原子读或原子写操作是任何其他操作不得插入。

假定使用存储器中某个单元来表示一个锁变量：其值为0时表示解锁，为1表示加锁。一个处理器尝试对锁单元加锁，方法时用一个寄存器中的1与该锁单元的值进行交换。交换后该锁单元的新值为1，返回值（锁单元的原值）如果是1，表示这个锁已经被其他处理器占用；返回值为0，表示锁时自由的，尝试加锁成功。

用交换原语实现同步的关键时操作的原子性：交换操作时不可分割的，并且由硬件对两个同时执行的交换操作进行排序。

实现单个的原子存储器操作给处理器的设计者带来了若干挑战，一种可行的方法时采用指令对，第二条指令返回一个表明这对指令是否原子执行的标志值。当一对指令是原子的，没有哪个处理器能够改变这两个指令执行之间的数据值。

在MIPS处理器中这一指令对包括一条叫作链接取数( load linked)的特殊取数指令和一条叫作条件存数( store conditional) 的特殊存数指令。我们顺序地使用这两条指令：如果链接取数指令所指定的锁单元的内容在相同地址的条件存数指令执行前已被改变，那么条件存数指令就执行失败。我们定义条件存数指令完成以下功能：保存寄存器的值，并且如果执行成功则将寄存器的值修改为1，如果失败则修改为0。因为链接取数指令返回锁单元的原始值，条件存数指令执行成功的时候才返回1，下面的指令序列实现了存储器单元的原子交换。存储器单元的地址由$s1中的值指出。

```assembly
again:
	addi $t0, $zero, 1	# copy loacked value
	ll	$t1, 0($s1)		# load linked
	sc	$t0, 0($s1)		# store conditional
	beq $t0, $zero, again	# branch if store fails
	add $s4, $zero, $t1	# put load value in $s4
```

在 ll 和 sc 两条指令之间的任何时候有处理器插入，并修改了该锁单元的值， 指令 sc 都会将 $s0 置为 0 ， 引起这段指令序列重新执行。在指令序列的最后，寄存器 $s4 中的值和 $s1 指向的锁单元的值发生了原子交换。

### 翻译并执行程序

![image-20211118152322131](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118152322131.png)

#### 编译器

将C程序转换成一种机器能够理解的符号形式的汇编语言程序

- 汇编语言：一种符号语言，能被翻译成二进制机器语言

#### 汇编器

伪指令：汇编语言指令的一个变种，通常被看作一条汇编指令

比如伪指令：

```assembly
move $t0, $t1
```

即使MIPS体系结构中不存在这条指令，MIPS汇编器也能识别它，将其翻译成：

```assembly
add $t0, $zero, $t1
```

伪指令使MIPS拥有比硬件锁实现的更为丰富的汇编语言指令集，唯一代价就是保留了一个由汇编器使用的寄存器$at。

**汇编器**的主要任务使汇编成机器代码，汇编器将汇编语言程序转换成目标文件，它包括机器语言指令、数据和指令正确放入内存需要的信息。

- 符号表：一个用来匹配标记名和指令所在内存字的地址的列表

UNIX系统中的目标文件通常包括：

- 目标文件头，描述目标文件其他部分的大小和位置
- 代码段，包含机器语言代码
- 静态数据段，包含在程序生命周期内分配的数据
- 重定位信息，标记了一些在程序加载进内存使依赖于绝对地址的指令和数据
- 符号表，包括未定义的剩余标记，如外部引用
- 调试信息，包含一份说明目标模块如何编译的简明描述

#### 链接器

**链接器**：是一个系统程序，把各个独立汇编的机器语言程序组合起来并且解决所有未定义的标记，最后生成**可执行文件**。

链接器工作的3个步骤:

- 将代码和数据模块象征性的放入内存
- 决定数据和指令标签的地址
- 修补内部和外部引用

可执行文件：一个具有目标文件格式的功能程序，不包含未解决的引用。可以包含符号表和调试信息。“剥离的可执行程序”不包含这些信息，可能包含加载器所需要的重定位信息。

#### 加载器

在UNIX系统，加载器按照如下步骤工作：

- 读取可执行文件头来确定代码段和数据段的大小
- 为正文和数据创建一个足够大的地址空间
- 将可执行文件中的指令和数据复制到内存中
- 把主程序的参数复制到栈顶
- 初始化机器寄存器，将栈指针指向第一个空位置
- 跳转到启动例程，将参数赋值到参数寄存器并且调用程序的main函数。当main函数返回时，启动例程通过系统调用exit终止程序。

**加载器：**把目标程序转载到内存一准备运行的系统程序

#### 动态链接库

**动态链接库**：在程序执行过程中才被链接的库例程

#### 启动一个Java程序

![image-20211118161502768](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118161502768.png)

![image-20211118161704826](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118161704826.png)

- Java字节码：为了解释Java程序而设计的指令集中的指令
- Java虚拟机：解释Java字节码的程序
- 即时编译器：一类通用编译器的名称，编译器能够在运行时将解释的代码段翻译成宿主计算机上的机器语言。

-----------------

### 以一个C排序程序作为完整的例子

#### swap过程

```C
void swap(int v[], int k)
{
	int temp;
	temp = v[k];
	v[k] = v[k + 1];
	v[k + 1] = temp;
}
```

##### 为 swap 分配寄存器

将参数 v 和 k 分配在寄存器 $a0 , $a1 中。由于 swap 是一个叶过程，所以我们为唯一的剩余变量 temp 分配寄存器 $t0 。

##### 为 swap 过程体生成代码

```assembly
sll $t1, $a1, 2	# t1 = k * 4
add $t1, $t1, $a0	# t1 = v[k] 的地址

lw $t0, 0($t1)	# temp = v[k]
lw $t2, 4($t1) 	# t2 = v[k + 1]

sw $t2, 0($t1)	# v[k] = t2
sw $t0, 4($t1)	# v[k + 1] = t0
```

##### 完整的 swap 程序

```assembly
swap：
	sll $t1, $a1, 2	# t1 = k * 4
    add $t1, $t1, $a0	# t1 = v[k] 的地址

    lw $t0, 0($t1)	# temp = v[k]
    lw $t2, 4($t1) 	# t2 = v[k + 1]

    sw $t2, 0($t1)	# v[k] = t2
    sw $t0, 4($t1)	# v[k + 1] = t0
    
    jr $ra
```

####  sort 过程

```c
void sort (int v[], int n)
{
	int i, j;
    for (i = 0; i < n; i++) {
		for (j = i - 1; j >= 0 && v[j] > v[j + 1]; j--) {
			swap(v, j);
        }
    }
}
```

##### sort 的寄存器分配

为过程 sort 的两个参数 v 和 n 分配参数寄存器 $a0 和 $a1，为变量 i 和 j 分配寄存器 $s0 和 $s1。

##### 为 sort 过程生成代码

第一个循环

```assembly
	move $s0, $zero		# i = 0
for1tst:
	slt $t0, $s0, $a1	# t0 = 0 if i >= n
	beq $t0, $zero, exit1	# go to exit1 if i >= n
	……
	addi $s0, $s0, 1	# i++
	j for1tst	# 循环
exit1:
```

第二个循环

```assembly
addi $s1, $s0, -1	# j = i - 1
for2tst:
	slti $t0, $s1, 0	# t0 = 1 if s1 < 0
	bne $t0, $zero, exit2	# go to exit2 if s1 < 0
	sll $t1, $s1, 2		# t1 = j * 4
	add $t2, $a0, $s1	# t2 = v[j]的地址
	lw $t3, 0($t2)		# t3 = v[j]
	lw $t4, 4($t2)		# t4 = v[j + 1]
	slt $t0, $t4, $t3	# t0 = 0 if t4 > t3
	beq $t0, $zero, exit2	# go to exit2 if t4 >= t3
	……
	addi $s1, #s1, -1	# j--
	j for2tst	# 循环
exit2:
```

##### sort 中的过程调用

第二个for循环的循环体：

```assembly
jal swap
```

##### sort 中的参数传递

sort 过程需要使用寄存器 $s0 和 $s1 中的值，而 swap 过程需要将它的参数放入这些寄存器。我们可以将 sort 的参数复制到其他的寄存器中，使 swap 过程可以使用寄存器 $a0 和 $a1。

```assembly
复制
move $s2, $a0
move $s3, $a1
将参数传递给 sort 
move $a0, $s2
move $a1, $s1
```

##### 在 sort 中保留寄存器

保存和恢复寄存器值的代码了。因为 sort 是一个过程并且要递归使用，所以需要用寄存器 $ra 保存返回地址。

```assembly
addi $sp, $sp, -20
sw $ra, 16($sp)
sw $s3, 12($sp)
sw $s2, 8($sp)
sw $s1, 4($sp)
sw $s0, 0($sp)
```

##### 完整的 sort 过程

```assembly
sort:
# 保存寄存器值
	addi $sp, $sp, -20
    sw $ra, 16($sp)
    sw $s3, 12($sp)
    sw $s2, 8($sp)
    sw $s1, 4($sp)
    sw $s0, 0($sp)
# 移动参数
    move $s2, $a0
	move $s3, $a1
# 循环外部	
	move $s0, $zero		# i = 0
for1tst:
	slt $t0, $s0, $a1	# t0 = 0 if i >= n
	beq $t0, $zero, exit1	# go to exit1 if i >= n
# 循环内部	
	addi $s1, $s0, -1	# j = i - 1
for2tst:
	slti $t0, $s1, 0	# t0 = 1 if s1 < 0
	bne $t0, $zero, exit2	# go to exit2 if s1 < 0
	sll $t1, $s1, 2		# t1 = j * 4
	add $t2, $a0, $s1	# t2 = v[j]的地址
	lw $t3, 0($t2)		# t3 = v[j]
	lw $t4, 4($t2)		# t4 = v[j + 1]
	slt $t0, $t4, $t3	# t0 = 0 if t4 > t3
	beq $t0, $zero, exit2	# go to exit2 if t4 >= t3
# 传递参数和调用	
	move $a0, $s2
	move $a1, $s1
	jal swap
# 循环内部	
	addi $s1, #s1, -1	# j--
	j for2tst	# 循环
exit2:
	
	addi $s0, $s0, 1	# i++
	j for1tst	# 循环
exit1:
# 恢复寄存器值
	lw $s0, 0($sp)
	lw $s1, 4($sp)
	lw $s2, 8($sp)
	lw $s3, 12($sp)
	lw $ra, 16($sp)
	addi $sp, $sp, 20
# 过程返回	
	jr $ra
```

- 优化：可以内联过程，把 swap 过程复制过来

### 数组与指针

```c
clear1(int array[], int size)
{
	int i;
	for (i = 0; i < size; i++) {
		array[i] = 0;
	}
}
clear2(int *array, int size)
{
	int *p;
	for (p = &array[0]; p < &array[size]; p = p + 1) {
		*p = 0;
	}
}
```

#### 用数组实现clear

```assembly
move $t0, $zero				# i = 0
loop1:
	sll $t1, $t0, 2			# t1 = i * 4
	add $t2, $a0, $t1		# t2 = array[i]的地址
	sw $zero, 0($t2)		# array[i] = 0
	addi $t0, $t0, 1		# i++
	slt $t3, $t0, $a1		# t3 = i < size
	bne $t3, $zero, ,loop1	# if i < size go to loop1
```

#### 用指针实现clear

5、6两句可以写到循环外面，只要计算一次就好了

```assembly
move $t0, $a0				# p = array[0]的地址
loop2:				
	sw $zero, 0($t0)		# Memory[p] = 0
	addi $t0, $t0, 4		# p = p + 4
	sll $t1, $a1, 2			# t1 = size * 4
	add $t2, $a0, $t1		# t2 = address of array[size]
	slt $t3, $t0, $t2		# t3 = (p < &array[size])
	bne $t3, $zero, loop2	# if p < &array[size] go to loop2
```

#### 比较两个版本的clear

指针可以不用那么多次的计算地址，没有sw操作。总而言之就是效率更高，不高好在现在的编译器已经可以自动帮我们优化了。

### 高级内容：编译C语言和解释Java语言

To Do

### 实例：ARMv7（32位）指令集

To Do

### 实例：x86指令集

To Do

### 实例：ARMv8（64位）指令集

To Do

### 谬误与陷阱

谬误：更强大的指令意味着更高的性能

谬误：使用汇编语言编程来获得最高的性能

谬误：商用计算机二进制兼容的重要性意味着成功的指令集不需改变

陷阱：忘记在字节寻址的机器中，连续的字地址相差不是1

陷阱：在自动变量的定义过程外，使用指针指向该变量

### 小结

计算机的两个准则：

- 指令的使用与数字没有区别
- 使用可修改的存储器

硬件设计的3条准则：

- 简单源于规整
- 越小越快
- 优秀的设计需要好的折中

加速大概率事件的体现：

条件分支的PC相对寻址和大常数操作数的立即数寻址。

![image-20211118231958804](https://gitee.com/ceyewan/pic/raw/master/images/image-20211118231958804.png)
