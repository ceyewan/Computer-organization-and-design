## 处理器

### 引言

第一章中，我们看到一台计算机的性能主要有三个关键因素决定：指令数目、时钟周期长度和每条指令所需要的时钟周期数（CPI）

第二章中，阐述了编译器和指令集决定了一个程序所需要的指令数目。

处理器的实现方式则决定了时钟周期长度和CPI。在本章中，我们为MIPS指令集的两种不同实现方式分别建立数据通路和控制单元

#### 一个基本的MIPS实现

我们将要设计的实现方式包含了MIPS指令集的一个核心子集：

- 存储器的访问指令：取字（lw）和存字（sw）
- 算术逻辑指令：加法（add）、减法（sub）、与运算（AND）、或运算（OR）和小于则置位（slt）
- 分支指令：相等则分支（beq）和跳转（j）                                         

##### 实现方式概述

每条指令的前两步是一样的：

1. 程序计时器（PC）指向指令所在的存储单元，并从中取出指令
2. 通过指令字段内容，选择读取一个或者两个寄存器。对于取字指令，只需要读取一个寄存器，其他大多数指令要求读取两个寄存器

后面三步也大致相同。除跳转指令外的所有指令在读取寄存器后，都要使用算术逻辑单元（ALU）。存储访问指令用ALU计算地址，算数逻辑指令用ALU执行运算，分支指令用ALU进行比较。

MIPS实现的抽象视图：

![image-20211120110409353](https://gitee.com/ceyewan/pic/raw/master/images/image-20211120110409353.png)

1. 在图中的许多位置，某个单元的数据可能来自于两个不同的单元。例如写入PC的值可能来自两个加法器中的一个，写入寄存器堆的数据可能来自ALU或数据存储器，ALU的第二个输入可能来自寄存器或指令中的立即数字段。实际上，不能简单地直接将这些数据线连在一起，必须增加一个逻辑单元用于从不同数据来源中选择一个送给目标单元。这个过程通常是由一个叫多选器的逻辑单元完成的。
2. 图中的许多单元的控制依赖于当前执行指令的类型。例如，存取指令读写数据存储器，取数指令和算术逻辑指令写入寄存器堆。ALU根据不同的指令执行不同的操作。

下图增加了三个必需的多选器和主要功能单元的控制信号。还增加了一个控制单元，它以指令为输入、决定功能单元和两个多选器的控制信号。第三个多选器用来决定是将PC + 4还是分支目的地址写入PC，该多选器在执行beq指令时，根据ALU进行比较时设置的Zero标志位选择写入PC的值。

![image-20211120131519025](https://gitee.com/ceyewan/pic/raw/master/images/image-20211120131519025.png)

----------------------------

### 逻辑设计的一般方法

组合单元：一个操作单元，如与门或ALU

状态单元：一个存储单元，如寄存器或存储器

一个状态单元至少有两个输入和一个输出。两个必要的输入：

1. 要写入单元的数据值
2. 决定何时写入的时钟信号

输出：

1. 提供了在前一个时钟信号写入单元的数据值

包含状态的逻辑部件又被称为时序的，因为它们的输出由输入和内部状态共同决定。

##### 时钟方法

时钟方法规定了信号可以读出和写入的时间，可以避免一个信号同时被写入和读出。

边沿触发的时钟方法：在时序逻辑单元中存储的所有值都只允许在时钟跳变的边沿时改变。因为只有状态单元能存储数据值，所有的组合逻辑都必须从状态单元集合接收输入，并将输出写入状态单元集合中。其输入为之前某时钟周期写入的数据，其输出可供之后某时钟周期使用。

- 时钟方法：用来确定数据相对于时钟何时稳定和有效的方法
- 边沿触发的时钟：一种所有的状态改变发生于时钟沿的时钟机制

![image-20211120150656270](https://gitee.com/ceyewan/pic/raw/master/images/image-20211120150656270.png)

> 本章假定所有的状态单元都是上升沿触发的

若某状态单元在每个有效的时钟边沿都进行写入操作，则可忽略写控制信号。相反，若某状态单元不是在每个有效的时钟边沿都进行写入操作，就需要一个写控制信号。写控制信号和时钟信号都是输入信号，只用时钟边沿到来并且当写控制信号有效时，状态单元才改变状态。

- 控制信号：用来决定多选器选择或指示功能单元操作的信号，与数据信号相对应，数据信号包含由功能单元操作的信息
- 有效：信号为逻辑高或真
- 无效：信号为逻辑低或假

![image-20211120151340104](https://gitee.com/ceyewan/pic/raw/master/images/image-20211120151340104.png)

上升沿读出，在时钟周期内进行组合逻辑，然后再在上升沿写入。

---------------------------

### 建立数据通路

- 数据通路部件：一个用来操作或保存处理器中数据的单元。在MIPS中，数据通路部件包括指令存储器、数据存储器、寄存器堆、ALU和加法器
- 程序计时器：存放下一条将要被执行指令的地址的寄存器

要执行任何一条指令，首先要从存储单元中将指令取出，为准备执行下一条指令，也必须增加程序计时器使其指向下一条指令，即后移4个字节。该ALU只进行add操作。

![image-20211120201943336](https://gitee.com/ceyewan/pic/raw/master/images/image-20211120201943336.png)

处理器的32个通用寄存器位于一个叫做寄存器堆的结构中。寄存器堆即寄存器集合，其中的寄存器都可以通过指定相应的寄存器号来进行读写。

- 寄存器堆：包含一系列寄存器的状态单元，可以通过提供寄存器号进行读写。

R型指令有3个寄存器操作数，每条指令都要从寄存器堆读出两个数据字，再写入一个数据字。读出一个数据字，寄存器堆又需要输入一个要读的寄存器号和一个从寄存器堆读出结果的输出指示。写入一个数据字，寄存器堆要有两个输入：一个提供要写的寄存器号、另一个提供要写的数据。

ALU有两个32位输入、一个32位输出，还有一个一位输出指示其结果是否为0。ALU由4位的ALU操作信号（ALUOp）控制。

寄存器号的输入都是5位，指令中只分配了5位，总共32个5位也够了。

![image-20211120202403016](https://gitee.com/ceyewan/pic/raw/master/images/image-20211120202403016.png)

存取指令。

```assembly
lw $t1, offset_value($t2)
sw $t1, offset_value($t2)
```

这类指令，通过将基址寄存器 $t2 的内容与指令中的16位带符号偏移地址相加，得到存储器地址。还需要一个单元将16位的偏移地址符号拓展为32位的带符号值，以及一个保存读出或写入数据的存储单元。

beq指令有3个操作数，其中两个为寄存器，用于比较是否相等，另一个数为16位偏移量，用于计算相对于分支指令所在地址的分支目标地址。指令格式 ：

```assembly
beq $t1, $t2, offset
```

为了实现该指令，我们必须将PC值与符号拓展后的指令偏移字段相加得到分支目标地址。

- 指令集规定计算分支地址时使用的基地址，是分支指令的下一条指令的地址。原因是我们在取指通路中计算了PC + 4，用这个值作为计算分支指令目标地址时的基地址比较容易实现。
- 系统结构还规定了偏移量左移2位以指示以字为单位的偏移量，这样偏移量的有效范围就扩大了4倍

分支目标地址：该地址指定了一个分支，如果分支发生，那么它将成为新的程序计时器（PC）。在MIPS架构中，指令偏移与分支指令的下一条指令地址之和组成分支目标。

![image-20211120204651234](https://gitee.com/ceyewan/pic/raw/master/images/image-20211120204651234.png)

- 延迟的分支：不管分支条件是否满足，分支指令之后的那条指令总被执行的一种分支（流水线设计）

##### 创建一个简单的数据通路

算术逻辑指令（R型指令）的数据通路和访存指令的数据通路很相似。主要区别在于：

- 算术逻辑指令使用ALU，并且其输入来自两个寄存器。存储指令也使用ALU来进行地址计算，但ALU的第二个输入时对指令中16位偏移地址进行符号拓展后的值。
- 存入目标寄存器中的值来自于ALU（对R型指令而言）或者存储器（对取数指令而言）

为了只用一个ALU和一个寄存器堆来创建一个数据通路，ALU的第二个输入和要存入寄存器堆的数据都需要两个不同的来源。所以，要在ALU的输入和寄存器堆的输入数据处各加入一个多选器：

![image-20211120205437859](https://gitee.com/ceyewan/pic/raw/master/images/image-20211120205437859.png)

将取数数据通路、分支数据通路、R型指令和访存指令数据同理合并在一起建立一个简单的MIPS体系结构数据通路。由于分支指令用主ALU对寄存器操作数进行比较，所以还需要图4-9中的加法器完成分支目标地址的计算。此外还增加了一个多选器，用于选择是将顺序的指令地址还是分支指令地址写入PC。

![image-20211120205938473](https://gitee.com/ceyewan/pic/raw/master/images/image-20211120205938473.png)

在完成这个简单的数据通路后，可以加上控制单元。控制单元必须能够接收输入、能够产生每个状态单元的写信号、每个多选器的选择信号和ALU的控制信号。

-------

### 一个简单的实现机制

用上一节的数据通路和增加一个简单的控制单元来实现MIPS体系结构。

#### ALU控制

![image-20211120220243523](https://gitee.com/ceyewan/pic/raw/master/images/image-20211120220243523.png)

使用一个小的控制单元即可生成4位的ALU控制信号，其输入为指令的funct字段和2位的ALUop字段。该ALU控制单元输出4位信号，直接对ALU进行控制。

多级译码：主控制单元生成ALUop作为ALU控制单元的输入，再由ALU控制单元生成真正的控制ALU的信号。使用多级译码可以减小主控制单元的规模。使用多个小控制单元还可以提高控制单元的速度。

因为funct功能字段只有很小一部分有意义，并且只有当ALUop取值位10时才使用功能字段，我们可以使用一个小逻辑单元去识别可能取的值，以正确生成ALU控制信号。

![image-20211219160551967](https://gitee.com/ceyewan/pic/raw/master/images/image-20211219160551967.png)

#### 主控制单元的设计

![image-20211123154117826](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123154117826.png)

MIPS指令格式遵循以下规则：

- op字段，总是头6位
- R型指令、分支指令、存取指令，要读取rs、rt字段
- 存取指令的基址寄存器再rs字段中
- 相等则分支指令和存取指令的16位偏移量在最后面16位
- R型指令的目标寄存器在rd字段，取数指令rt字段。所以我们需要一个多选器，指示要写的寄存器在哪个字段。

![image-20211123154650610](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123154650610.png)

| 控制信号名 | 无效时的含义                            | 有效时的含义                                         |
| ---------- | --------------------------------------- | ---------------------------------------------------- |
| RegDst     | 写寄存器的目标寄存器来自rt字段          | 写寄存器的目标寄存器来自rd字段                       |
| RegWrite   | 无                                      | 寄存器堆写能有效                                     |
| ALUSrc     | 第二个ALU操作数来自寄存器堆的第二个输入 | 第二个操作数为指令低16位的符号拓展                   |
| PCSrc      | PC = PC + 4                             | PC由分支地址代替                                     |
| MemRead    | 无                                      | 数据存储器读有效                                     |
| MemWrite   | 无                                      | 将写入数据输入端的数据写入到用地址指定存储器单元中取 |
| MemtoReg   | 写入寄存器的数据来自ALU                 | 写入寄存器的数据来自数据寄存器                       |

当两路多选器的控制信号有效时，选择第一个输入，否则，选择第0个输入。

那么，这些控制信号又是由什么控制的呢？除了PCSrc外，都可只根据指令的操作码来确定。PCSrc信号有效是指令为相等则分支（由控制单元决定），且用于等值比较的ALU的零输出有效。为生成PCSrc信号，需要一个来自控制单元称为branch的信号和ALU的零输出信号相与。

##### 数据通路的操作

![image-20211123155920099](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123155920099.png)

结合上下两幅图，我们来看一下执行R型指令（如add $s1, $s2, $s3)

1. 从指令存储器取出指令，PC自增

2. 从寄存器堆中读出寄存器$s2, $s3。同时，主控制单元计算出各控制信号的状态。

3. ALU根据funct字段（5-0位）确定ALU的功能，对从寄存器堆读出的数据进行操作
4. 将ALU的结果写回寄存器堆，目标寄存器是指令的15-11位。

对于取数指令（如：lw $t1, offset($t2))：

1. 从指令存储器取出指令，PC自增
2. 从寄存器堆读出$t2的值
3. ALU将从寄存器堆读出的值与符号拓展后的指令低16位相加（得到地址）
4. 将ALU的结果作为数据存储其的地址
5. 存储单元的数据写入寄存器堆，目标寄存器由指令的20-16位指出

对于相等则分支指令（如：beq $t1, $t2, offset)：

1. 从指令存储器取出指令，PC自增
2. 从寄存器堆读出寄存器 $t1 和 $t2 的值
3. ALU将从寄存器堆读出的两数相减。同时，PC + 4 的值和符号拓展并左移两位后的指令低16位相加，即分支目标地址
4. ALU的零输出决定哪个加法器的结果存入PC中

![image-20211123160016626](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123160016626.png)

##### 控制的结束



![image-20211123160406831](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123160406831.png)

这里，我们已经实现了MIPS核心指令集绝大多数指令的 **单周期实现** ，在此基础上我们再加上跳转指令。

- 单周期实现：一个时钟周期执行一条指令的实现机制。

跳转指令无条件改变PC，跳转地址的最低两位恒为00。32位跳转指令的次低26位（就是27 - 2）来自指令的26位立即数，高4位来自跳转指令的PC + 4。也就是说，跳转指令由3部分拼接而成：

1. 当前PC + 4的高4位
2. 跳转指令的26位立即数
3. 低位00（因为地址需要乘以4，所以最后一定是00）

#### 为什么不使用单周期实现方式

**性能**不行

-------------------------------------

### 流水线概述

**流水线**是一种实现多条指令重叠执行的技术，与生产流水线类似。

洗衣服例子。流水线就是把同样的原理应用到处理器中。

一个MIPS指令包含如下5步：

1. 从指令存储器读取指令
2. 指令译码的同时读取寄存器（译码用op字段，读取寄存器用的是后面的字段
3. 执行操作和计算地址
4. 从数据存储器中读取操作数（存字取字）
5. 将结果写回寄存器

```
指令执行时间（流水线） = 指令执行时间（非流水线） / 流水线级数
```

流水线带来的性能的提高是通过增加指令的吞吐率，而不是减少单条指令的执行时间

#### 面向流水线的指令集设计

1. 所有的MIPS指令的长度都是相同的
2. MIPS只有很少几种指令格式
3. MIPS中的存储器操作数仅出现在存取指令中（这一限制意味着可以利用执行级计算存储器地址，然后可以接着在下一级访问存储器。如果可以直接操作内存中的操作数，那么第三级和第四级就会拓展为地址计算、存储访问和执行阶段）
4. 所有操作数必须在存储器中对齐

#### 流水线冒险

1. 结构冒险：硬件不支持多指令在同一时钟周期执行。不过MIPS指令集是为流水线设计的，它使得设计者在设计流水线时非常容易就能避免结构冒险。

2. 数据冒险：发生在由于一条指令必须等待另一条指令完成而造成流水线暂停的情况下。

   ```assembly
   add $s0, $t0, $t1
   sub $t2, s0, $t3
   加法直到第五步才写回结果，那么减法就得等着
   ```

   在解决数据冒险问题之前不需要等待指令的执行结束，对于上述代码，一旦ALU生成了加法结果，无需写入寄存器，就可以直接将它用作减法运算的一个输入项。从内部资源中直接提前得到缺少的运算项的过程称为前推或者旁路。

   - 前推：也叫旁路，一种解决数据冒险的方法，具体做法是从内部寄存器而非程序员可见的寄存器或存储器中提前取出数据。

   ![image-20211123181133170](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123181133170.png)

   即使采用了旁路机制，在遇到 **取数-使用型数据冒险**时，流水线不得不阻塞一个步骤。图中显示了一个重要的流水线概念，叫**流水线阻塞**，昵称为**气泡**。

   ![image-20211123181425089](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123181425089.png)

   重新安排代码也能避免流水线阻塞。

   由旁路可以得到设计MIPS体系结构指令集的另一个原则：每条MIPS指令最多只写一个结果并且在流水线的最后一级执行。

3. 控制冒险：分支冒险。因为取得的数据不是所需要的（或者说指令地址的变化不是流水线所预测的）而导致指令不能再预定的时钟周期内执行。

   两种解决办法：

   - 阻塞
   - 预测（计算机时采用这种方法）

   分支预测：一种解决分支冒险的方法，它预测分支结果并立即沿预测方向执行，而不是等分支结果确定后才开始。

   计算机中动态预测方法的一种比较普遍实现方式是保存每次分支的历史记录，然后利用这个历史记录来预测。

#### 对流水线概述的小结

- 延迟：流水线的级数或者顺序执行过程中两条指令间的级数

流水线设计者必须解决结构冒险、控制冒险、数据冒险。而分支预测、旁路和阻塞机制能够在保证得到正确结果的前提下提高计算机的性能。

---------------------------

### 流水线数据通路及其控制

![image-20211123182751680](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123182751680.png)

1. IF：取指令
2. ID：指令译码，读寄存器堆
3. EX：执行或计算地址
4. MEM：数据存储器访问
5. WB：写回

一般来讲，从左往右，不会反向移动，但是有两个例外：

1. 写回阶段，把结果写回数据通路中间的寄存器堆
2. 选择PC的下一个值时，需要自增的PC和MEM级的分支地址间进行选择

这两个例外会影响之后的指令，第一个例外会导致数据冒险，第二个例外会导致控制冒险。

图4-34中，指令存储器只在每条指令的5个步骤中的一步中用到，因此我们允许它在其他4步中被其他的指令共享。为了在其他4步中保持指令的值，从指令存储器中读出的数据必须保存在寄存器中。

![image-20211123190149710](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123190149710.png)

如下图，当寄存器或存储器被读取时，图4-35中活动的数据通路部件用灰色表示。在图中用阴影表示其右半部分；当它们被写入时，用阴影来表示其左半部分。

下面我们来分析一下装载指令：             

![image-20211123192502717](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123192502717.png)

1. 取指令：图4-36的顶端表示指令使用PC中的地址从存储器中读取数据，然后将数据放入IF/ID流水线寄存器中。PC地址加4然后写入PC以便为下一个时钟周期做好准备。增加后的地址同时也存入了IF/ID流水线寄存器以便后面的指令使用（如beq）
2. 指令译码与寄存器堆的读取：图4-36底部显示的是IF/ID流水线寄存器的指令部分，其中包括一个16位的立即数（可拓展位32位）和两个寄存器号（用于读取寄存器）。这三个值和自增的PC地址一起存入ID/EX流水线寄存器中。

![image-20211123193643883](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123193643883.png)

3. 执行或者地址计算：图4-37表示装载指令使用从ID/EX流水线寄存器中读取由寄存器1传过来的值以及经符号拓展后的立即数，并用ALU将它们相加，和值存入EX/MEM流水线寄存器中。
4. 存储器访问：图4-38的顶端表示装载指令使用从EX/MEM流水线寄存器中得到的地址读取数据存储器，并将数据存入MEM/WB流水线寄存器
5. 写回：图4-38的底部表示了最后一个步骤，即从MEM/WB流水线读取数据并将它写入图中部的寄存器堆

![image-20211123194403059](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123194403059.png)

存储指令的5个执行步骤：

1. 取指令：利用PC中的地址从存储器中读取指令，然后将指令放入IF/ID流水线寄存器中。这个步骤发生在指令译码之前，所以图4-36中顶端部分既适用于装载指令也适用于存储器指令。
2. 指令译码与寄存器堆的读取：IF/ID流水线寄存器的指令部分包括一个16位的立即数（可拓展位32位）和两个寄存器号（用于读取寄存器）。读出的两个寄存器值和符号拓展后的32位立即数都放在ID/EX流水线寄存器中。图4-36底部同时也描述装载指令的第二个流水级。由于此时并不知道要执行的指令类型，因此所有的指令都执行这两个部分。
3. 指令执行或地址计算：图4-39描述了sw指令在流水线中的第三步，有效地址存放在EX/MEM流水线寄存器中。

![image-20211123195318330](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123195318330.png)

4. 存储器访问：图4-40的顶端描述的是数据写入存储器的过程。需要写入存储器的数据在较早的流水线中已经读出并存放在ID/EX中。在MEM级唯一获得这个数据的方法就是把数据放入EX步骤中的EX/MEM流水线寄存器中，这一过程将与有效地址放入EX/MEM中类似
5. 写回：图4-40的底部描述了存储指令的最后一步。存储指令在写回步骤中不做任何事情。由于存储指令后的每一条指令都已经进入流水线，所以无法加速这些指令。因此，任何一条指令都必须经过流水线的每一个步骤，即使这个步骤什么也不做。

![image-20211123195951396](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123195951396.png)

存储指令再次说明在流水线中为了从前面的流水线向后面的流水线传递信息，必须将信息放入流水线寄存器中，否则否则当下一条指令进入该流水级时这些信息会丢失。

现在我们可以修复图4-38中装载指令设计的错误了。在装载指令执行的最后一级写回了哪个寄存器呢？哪条指令提供了写寄存器号呢？在IF/ID流水线寄存器中的指令提供了写寄存器号，但是很显然现在这条指令已经是装载指令之后的指令了！

因此，我们要在装载指令中保存目的寄存器号。就像存储指令为了MEM的需要将寄存器的内容从ID/EX传送到EX/MEM中一样，为了WB级使用的需要，装载指令必须把寄存器号从ID/EX经过EX/MEM传送到MEM/WB中。从另一个角度来考虑寄存器号的传递，为了共享流水线的数据通路，我们需要在IF中保存读取的指令，因此每一个流水线寄存器都要保存当前和后续流水线所需要的部分指令。

![image-20211123203603077](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123203603077.png)![image-20211123203634611](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123203634611.png)

#### 图形化表示的流水线

```assembly
lw $10, 20($1)
sub $11, $2, $3
add $12, $3, $4
lw $13, 24($1)
add $14, $5, $6
```

![image-20211123204149735](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123204149735.png)

#### 流水线控制

![image-20211123204726165](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123204726165.png)

1. 取指令：读指令存储器和写PC的控制信号总是有效的，因此在取指令阶段没有特别需要控制的内容。
2. 指令译码/寄存器堆读：不需要设置控制信号
3. 指令执行/地址计算：控制器由RegDst、ALUOp、ALUSrc，根据这些信号选择结果寄存器、ALU操作、并为ALU读取数据2或符号拓展后的立即数。
4. 存储器访问：控制信号有Branch、MemRead和MemWrite。这些控制信号分别由相等则分支、装载指令和存储器指令设置。除非控制电路确定时一条分支指令并且ALU结果为0，否在将选择线性地址的下一条指令作为PCSrc信号
5. 写回：控制信号由MemtoReg和RegWrite，前者决定时将ALU结果还是存储器数据传输到寄存器堆，后者决定是否写入寄存器堆。

![image-20211123205819666](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123205819666.png)

实现控制就是为每一条指令的每一个步骤中的9个控制信号设置合适的值，最简单的实现方法就是拓展流水线寄存器使之包含有这些控制信号。

![image-20211123210149560](https://gitee.com/ceyewan/pic/raw/master/images/image-20211123210149560.png)

--------------------

### 数据冒险：旁路与阻塞

```assembly
sub $2, $1, $3
and $12, $2, $5
or $13, $6, $2
add $14, $2, $2
sw $15, 100($2)
```

后四条指令都依赖于第一条指令得到的寄存器$2的结果。

![image-20211124195816063](https://gitee.com/ceyewan/pic/raw/master/images/image-20211124195816063.png)

最后一个潜在的冒险可以通过设计相应的寄存器堆硬件解决。我们可以让写寄存器总是发生在时钟周期的前半部分而读寄存器发生在时钟周期的后半部分。因此不会发生冒险。

实际上，sub指令在EX级（第三个时钟周期）的末尾就可以得到需要的结果。and和or指令在EX级开始前需要数据。所以我么只要在刚得到数据时就将其旁路给所需的单元而不是等待其可以从寄存器堆总读出来，就可以无阻塞的执行指令了。

旁路是如何工作的呢？为了简化讨论，我们仅考虑如何直接传送EX段产生的数据，该数据可能是ALU运算的结果，也可能是地址计算的结果。这意味着如果一条指令试图在EX级使用一条指令在WB级才写入寄存器堆的数据时，我们需要提前将数据送到ALU的输入端。

流水线寄存器字段。如：ID/EX.RegisterRs表示一个需要流水线寄存器ID/EX获得的源寄存器号，其值可以在流水线寄存器中ID/EX中找到。点号的左边，表示流水线寄存器的名称；右边表示寄存器中字段的名称。

上面给出的这个指令序列的第一个冒险发生在sub $2, $1, $3的结果和and $12, $2, $5的第一个读操作数之间。这个冒险在and指令处于EX级而sub指令处于MEM级时就能检测出来，这就是冒险1a：

```
EX/MEM.RegisterRd = ID/EX.RegistreRs = $2
```

sub-or是一个2b类冒险：

```
MEM/WB.ResgiterRd = ID/EX.RegisterRt = $2
```

总是采用旁路的方式解决冒险是不正确的，因为某些指令可能不写回寄存器，就会产生一些不必要的旁路。一种解决方法是检测RegWrite信号是否活动，即通过检测流水线寄存器在EX和MEM级的WB控制字段确定RegWrite是否被有效。而且$0始终为0，这就需要在目标寄存器是$0的情况下，避免把$0按非零结果旁路。

需要在第一类冒险条件中加入附加条件 `EX/MEM.RegisterRd != 0` ，在第二类冒险条件中加入附加条件 `MEM/WB.RegisterRd != 0`。

如果可以从任何流水线寄存器而不仅仅从ID/EX中得到ALU的输入，那么就可以旁路所需的数据。通过在ALU的输入中加入多选器和正确的控制策略，就可以在存在相关性的情况下仍然能够全速运行流水线。

我们只考虑4个R型指令。因为ALU旁路多选器在EX中，所以旁路控制也在这一级中完成。因此，我们必须通过ID/EX流水线寄存器从ID中获得操作数寄存器号，以决定是否旁路相应的值。我们已经有了rt字段。在支持旁路前，ID/EX流水线寄存器未保存rs字段。因此，为了支持旁路，rs被加入ID/EX流水线寄存器中。

![image-20211124203152242](https://gitee.com/ceyewan/pic/raw/master/images/image-20211124203152242.png)

![image-20211124205857422](https://gitee.com/ceyewan/pic/raw/master/images/image-20211124205857422.png)

下面给出检测冒险的条件以及解决冒险的控制信号：

1. EX冒险：

```
if (EX/MEM.RegWrite 
and EX/MEM.RegisterRd != 0
and EX/MEM.RegisterRd = ID/EX.Registers)
ForwardA = 10

if (EX/MEM.RegWrite 
and EX/MEM.RegisterRd != 0
and EX/MEM.RegisterRd = ID/EX.Registert)
ForwardB = 10
```

`EX/MEM.RegisterRd`字段是ALU指令（来自Rd字段）或装载指令（来自Rt字段）的目标寄存器号。将前一条指令的结果旁路到任何一个ALU输入中，如果前一条指令要写寄存器堆且要写的寄存器号和ALU输入要读的寄存器号一致（只要不是0），那么就调整多选器从流水线寄存器EX/MEM中读取数值。

2. MEM冒险：

```
if (MEM/WB.RegWrite 
and MEM/WB.RegisterRd != 0
and MEM/WB.RegisterRd = ID/EX.Registers)
ForwardA = 01

if (MEM/WB.RegWrite 
and MEM/WB.RegisterRd != 0
and MEM/WB.RegisterRd = ID/EX.Registert)
ForwardB = 01
```

在WB级不会发生冒险。复杂的潜在数据冒险发生在WB级的指令结果、MEM级的指令结果和ALU指令源操作数之间。例如，在一个寄存器中对多个数字进行求和运算时，一系列的指令将会读写到同一寄存器：

```
add $1, $1, $2
add $1, $1, $3
add $1, $1, $4
……
```

在这种情况下，由于MEM级的结果时最新的，因而结果是由MEM级旁路得到的。这样，对MEM冒险的控制策略为：

```
if (MEM/WB.RegWrite 
and MEM/WB.RegisterRd != 0
and not(EX/MEM.RegWrite and EX/MEM.RegisterRd != 0
		and EX/MEM.RegisterRd != ID/EX.RegisterRs)
and MEM/WB.RegisterRd = ID/EX.Registers)
ForwardA = 01

if (MEM/WB.RegWrite 
and MEM/WB.RegisterRd != 0
and not(EX/MEM.RegWrite and EX/MEM.RegisterRd != 0
		and EX/MEM.RegisterRd != ID/EX.RegisterRt)
and MEM/WB.RegisterRd = ID/EX.Registert)
ForwardB = 01
```

![image-20211124212453525](https://gitee.com/ceyewan/pic/raw/master/images/image-20211124212453525.png)

图4-56中省略了装载指令和存储指令所需要的输入到ALU的带符号立即数。由于中央控制决定如何在寄存器和立即数之间进行选择，而且旁路单元选择流水线寄存器作为ALU的一个寄存器输入，因而最简单的解决方法就是加入一个2：1的多选器，由它在ForwardB多选器的输出和带符号立即数之间进行选择。如图4-57：

![image-20211124213829599](https://gitee.com/ceyewan/pic/raw/master/images/image-20211124213829599.png)

#### 数据冒险与阻塞

当一条指令试图读取由前一条装载指令读入的寄存器时，就无法使用旁路来解决冒险了。

![image-20211203155026100](https://gitee.com/ceyewan/pic/raw/master/images/image-20211203155026100.png)

因此，除了一个旁路单元以外，还需要一个冒险检测单元。工作于ID级，从而可以在装载指令于紧随其后的需要它结果的指令之间插入阻塞。控制条件如下：

```
if (ID/EX.MemRead and 
	((ID/EX.RegisterRt = If/ID.RegisterRs) or 		(ID/EX.RegisterRt = IF/ID.RegisterRt)))
	stall the pipeline
```

读取数据存储器的指令一定是装载指令，所以先检查是否为装载指令。后面两行是检测在EX级的装载指令的目的寄存器是否与在ID级的指令的某一个源寄存器相匹配。

如果处于ID级的指令被阻塞，那么处于IF级的指令也必须被阻塞。否则，已经取到的指令就会丢失。防止这两条指令继续执行的方法是保存PC寄存器和IF/ID流水线寄存器不变。

- 空指令：一种不进行任何操作或不改变任何状态的指令

在EX、MEM和WB级如果将所有的9个控制信号都清除，就会产生一个空指令。通过识别ID级的冒险，可以在流水线中插入一个气泡，方法就是把ID/EX流水线寄存器的EX、MEM和WB级的控制信号都置为0 。

![image-20211203161153542](https://gitee.com/ceyewan/pic/raw/master/images/image-20211203161153542.png)

旁路单元控制ALU多选器，从而可以用相应的流水线寄存器的值代替通用寄存器的值。冒险检测单元控制PC和IF/OD流水线寄存器的写入，以及在实际控制信号与全0中进行选在的多选器。

### 控制冒险

为了确保预取正确指令而导致的延迟叫作控制冒险或分支冒险。

![image-20211203161728691](https://gitee.com/ceyewan/pic/raw/master/images/image-20211203161728691.png)

#### 假定分支不发生

采用阻塞直到分支判断完毕来处理控制冒险的速度太慢。一种比较普遍的提高速度的方法是假定分支不发生，并继续执行顺序的指令流。如果分支发生，就丢弃已经读取并译码的指令，并按分支目标继续执行。

为了丢弃指令，只需要将最初的控制信号置为0即可，这一点与阻塞解决装载指令的数据冒险类似。不同之处在于当分支到达MEM级时必须分别改变在IF、ID和EX级的三条指令的控制信号，二对于装载指令的阻塞只需要将ID级的控制信号置为0，并将其从流水线中退出即可。分支冒险中的丢弃指令意味着必须能够将流水线的IF、ID和EX级的指令都**清除**。

#### 缩短分支的延迟

确定分支目标地址的时间越早，需要清除的指令就越少。

提前**计算分支目标指令**和**判断分支条件**

![image-20211203163028103](https://gitee.com/ceyewan/pic/raw/master/images/image-20211203163028103.png)

#### 动态分支预测

- 动态分支预测：根据运行信息在运行中进行分支预测。
- 分支预测缓存：分支历史记录表。一小块按照分支指令的低位地址索引的存储器区，其中包括一位或多位数据用于说明近期是否发生过分支。
- 分支延迟时间槽：紧跟延迟分支指令和时间片。在MIPS体系结构中，用不影响分支的一条指令填充到该时间段中。

#### 流水线小结

### 异常

控制中最难的部分之一是实现异常和中断——除分支以外改变正常指令执行顺序的事件。异常和中断最初是用来处理来自处理器内部的意外事件。

- 异常：也称中断，指的是打断程序正常执行的突发事件，用于检测溢出等。
- 中断：来自处理器外部的异常（某些体系用中断表示所有的异常）

#### MIPS体系结构中的异常处理

目前的实现中可能产生的两种异常是：未定义指令的执行和算术溢出。

异常发生时处理器必须进行的基本操作是：在***异常程序计数器（EPC）***中保存出错指令的地址，并且把控制权转交给操作系统的特定地址。

为了处理异常，操作系统处理要知道是哪条指令引起异常之外，还必须直到引起异常的原因。

表示异常产生原因的方法：

1. MIPS使用是设置一个状态寄存器（Cause寄存器），其中有一个字段用于记录异常产生的原因。
2. 另一种办法是使用向量中断。在向量中断中，控制权被转移到由异常原因决定的地址处。

![image-20211219223504429](https://gitee.com/ceyewan/pic/raw/master/images/image-20211219223504429.png)

MIPS体系结构的异常处理系统，统一入口地址位8000 0180（16进制）。实现向量异常：

- EPC：32位寄存器，用于保存发生异常的指令地址
- Cause: 记录异常原因的寄存器。

#### 在流水线实现中的异常

在流水线中，异常通常被视作另一种形式的控制冒险。例如，假设指令add产生了一个算术溢出。我们必须清除流水线中add指令后的一系列指令并且从新的地址开始取指。

![image-20211203192624735](https://gitee.com/ceyewan/pic/raw/master/images/image-20211203192624735.png)

![image-20211203192714017](https://gitee.com/ceyewan/pic/raw/master/images/image-20211203192714017.png)

### 指令级并行

流水线挖掘了指令间潜在的并行性，称为指令级并行（ILP）

另一种方法是复制计算机内部部件的数量，使得每个流水级可以其动多条指令，称为多发射

- 多发射：一种单时钟周期内发射多条指令的机制

每个阶段同时启动多条指令允许指令执行速率超过时钟速率，即CPI小于1。有时使用IPC，每时钟周期执行的指令数作为度量更方便，一个4GHz四路多发射微处理器能每秒执行160亿条指令。

实现多发射处理器的两种方式：

1. 编译器来做（静态多发射）
2. 硬件来做（动态多发射）

多发射流水线必须处理两个问题：

1. 往发射槽里发射多条指令。静态发射处理器由编译器处理发射指令的数量以及是何种指令；动态发射处理器由处理器在运行时处理
2. 处理数据冒险和控制冒险：静态发射处理器，由编译器静态处理；动态发射处理器通过硬件技术在执行时至少消除某些类别的冒险。

#### 推测的概念

推测是一种寻找和挖掘更大ILP的最重要方法（我推测是推测出没有依赖关系，那么就可以并行处理了）

- 推测：一种编译器或处理器推测指令结果以消除执行其他指令对该结果的依赖

（推测错了必须要能够回卷）

#### 静态多发射处理器

使用编译器来帮助封装多条指令并处理冒险。在一个静态发射处理器中，可以在给定的时钟周期内发射多条指令，也称**发射包**。

这种方法也叫：超长指令字

- 发射包：在一个时钟周期内发射的多条指令的集合。这个包可以由编译器静态生成，也可以由处理器动态生成。
- 超长指令字：一类可以同时启动多个操作的指令集，其中操作在单个指令中相互独立，并且一般都有独立的操作码字段。

使用延迟：在装载指令与可以无阻塞使用其结果的指令间间隔的时钟周期数

如果程序有循环。有一种编译技术可以获得更多性能，叫做循环展开。就是复制多份循环体，通过重叠不同循环体中的指令可以获得更高的指令级并行。

在循环展开过程中，编译器引入了几个临时寄存器，这个过程称为寄存器重命名。

- 寄存器重命名：由编译器或硬件对寄存器进行重命名以消除反相关。
- 方相关：也被称为名字相关，因为寄存器名的重用导致的相关，并非由两条指令中使用同一个值导致的真正相关。

#### 动态多发射处理器

动态多发射处理器也称**超标量处理器**，简称超标量。许多超标量处理器拓展了基本的动态发射决策，将动态流水线调度也包含在内。

- 超标量：一种高级流水线技术，可以使每个周期处理器能执行的指令数超过一条。
- 动态流水线调度：对指令进行重排序以避免阻塞的硬件支持

![image-20211219211431465](https://gitee.com/ceyewan/pic/raw/master/images/image-20211219211431465.png)

- 乱序执行：流水线执行的一种情况，即执行的指令被阻塞时不会导致后面的指令等待
- 顺序提交：流水线执行的结果以取值顺序写回程序员可见寄存器的一种提交方式

----------------------

### 谬误与陷阱

1. 谬误：流水线是一种简单的结构
2. 陷阱：没有考虑指令集的设计反过来会影响流水线
3. 谬误：流水线概念的实现与工艺无关

----------------------

### 小结

流水线提高了吞吐率，但是不能提高指令的内在执行时间

- 指令延迟：执行一条指令真正需要花费的时间

流水线和多发射都试着开发指令集并行，开发更高指令集并行的主要限制因素存在数据相关和控制相关。
